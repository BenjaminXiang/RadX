#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define EXTEND_LOCAL_GROUPS
#include "../include/driver.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"

// default values
#include "./includes.glsl"

// current work group size
//#define WG_COUNT 64u
const uint WG_COUNT = 64u;

// shared memory of...
shared uint localHistogram[RADICES];

// local size 
#ifdef ENABLE_TURING_INSTRUCTION_SET
const uint local_size_def = 1024u;
#else
const uint local_size_def = Wave_Size * RADICES;
#endif

layout ( local_size_x = local_size_def) in; // use many as possible
layout ( binding = 3, set = 0, scalar ) readonly subgroupcoherent buffer HistogramB {uint counts[][RADICES]; };
layout ( binding = 4, set = 0, scalar )          subgroupcoherent buffer PrefixSumB {uint partitions[][RADICES]; };

// X axis is workgroup count, Y is radices
void main() {
    [[flatten]] if (Local_Idx < RADICES) localHistogram[Local_Idx] = 0u;
    LGROUP_BARRIER

#ifdef ENABLE_TURING_INSTRUCTION_SET
    [[unroll, dependency_length(8)]] for (lowp uint rk=0u;rk<RADICES;rk+=Wave_Count_RX) {
#else
    { lowp uint rk = 0u;
#endif
        const lowp uint radice = rk + Wave_Idx;

        // calculate partitions by work-groups for every radice
        [[unroll]] for (lowp uint gp=0u;gp<WG_COUNT;gp+=Wave_Size_RX) {
            const lowp uint workgroup = gp+Lane_Idx;
            const highp uvec4 mask = subgroupBallot(workgroup < WG_COUNT && radice < RADICES);
            const uint 
                histv = subgroupInverseBallot(mask) ? counts[workgroup][radice] : 0u,
                scan = subgroupExclusiveAdd(histv), 
                sum = subgroupShuffle(histv + scan, subgroupBallotFindMSB(mask));

            uint pref = 0u; [[flatten]] if (electedInvoc()) { pref = add(localHistogram[radice], sum); }; pref = readFLane(pref);
            [[flatten]] if (subgroupInverseBallot(mask)) { partitions[workgroup][radice] = (pref + scan); };
        };
    };

    LGROUP_BARRIER

    [[unroll, dependency_length(2)]] for (lowp uint gp=0u;gp<WG_COUNT;gp+=Wave_Count_RX) {
        const lowp uint workgroup = gp + Wave_Idx;

        // calculate partition offsets of every radice
        uint partsum = 0u;
        [[unroll]] for (lowp uint rk=0u;rk<RADICES;rk+=Wave_Size_RX) {
            const lowp uint radice = rk + Lane_Idx;
            const highp uvec4 mask = subgroupBallot(workgroup < WG_COUNT && radice < RADICES);
            const uint histv = 
                subgroupInverseBallot(mask) ? localHistogram[radice] : 0u,
                scan = subgroupExclusiveAdd(histv),
                sum = subgroupShuffle(histv + scan, subgroupBallotFindMSB(mask));

            uint pref = 0u; [[flatten]] if (electedInvoc()) { pref = add(partsum, sum); }; pref = readFLane(pref);
            [[flatten]] if (subgroupInverseBallot(mask)) { partitions[workgroup][radice] += (pref + scan); };
        };
    };
};
