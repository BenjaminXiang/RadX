#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/driver.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"

//#define COPY_HACK_IDENTIFY // buffer names was swapped
#include "./includes.glsl"

const uint local_size_def = 1024u;//Wave_Size*1u;
layout (local_size_x = local_size_def) in; // use many as possible
shared m8pq utype_v data[local_size_def];
const m8pq u8x4_t max8u = u8x1_t(0xFFu).xxxx; // eq. 0xFFFFFFFFu
const uvec4 seq4x = {0u,1u,2u,3u};

layout ( binding = 0, set = 1, scalar ) readonly workgroupcoherent buffer KeyInU8B { u32vec4 Keys4x[]; };
layout ( binding = 2, set = 0, scalar )          workgroupcoherent buffer RadiceCacheOutB { uint32_t Keys8x4t[]; };

// TODO: transpose keys for faster access 
void main() {
    const uint wsize = NumElements;
    IFANY (wsize <= 0) return; const uint wcount = min(tiled(wsize, gl_NumWorkGroups.x*gl_WorkGroupSize.x*4), 2097152u);
    [[dependency_infinite]] for (uint w=0;w<wcount;w++) {
        const uint workID = gl_NumWorkGroups.x * w + gl_WorkGroupID.x, globalID = workID * gl_WorkGroupSize.x + Local_Idx;
        const bvec4 validAddress = lessThan(globalID.xxxx*4u+seq4x, wsize.xxxx); IFALL(all(not(validAddress))) break;

        data[Local_Idx] = utype_v(mix(max8u,BFE(Keys4x[globalID],int(push_block.Shift)*8,8),validAddress));
        Keys8x4t[globalID] = u8x4pack(data[Local_Idx]);
    };
};
